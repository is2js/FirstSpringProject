### 일대다, 다대일과 Pk, FK

- 하나의 글에 여러개의 댓글
	![20220518001542](https://raw.githubusercontent.com/is2js/screenshots/main/20220518001542.png)
	- 글의 입장: 일대다 = oneToMany
		![20220518001624](https://raw.githubusercontent.com/is2js/screenshots/main/20220518001624.png)
		![20220518001637](https://raw.githubusercontent.com/is2js/screenshots/main/20220518001637.png)
	- 댓글의 입장: 다대일 = manyToOne
		![20220518001706](https://raw.githubusercontent.com/is2js/screenshots/main/20220518001706.png)
		![20220518001718](https://raw.githubusercontent.com/is2js/screenshots/main/20220518001718.png)

### PK, FK
- DB 속 데이터들은 `id를 기준으로 관계`가 형성된다.
	![20220518001835](https://raw.githubusercontent.com/is2js/screenshots/main/20220518001835.png)
	- 자신을 대표하는 id: PK
	- 대상을 가리키는 id: FK


### 댓글 엔터티 -> Repository 설계
- my) article(일`1`)은 이미 설계가 된 상황에서 일대다 중 다`*`에 해당하는 DB -> entity -> repository 순으로 설계한다.

- 입장상 다대일 -> 댓글(다`*`)에서 -> 글(일`1`)을 찾아갈 수 있게 `entity`를 만들어야한다.
	- `db`에서는 `일의 id`를 `FK`로서 가지고와 `관계`를 만들었는데, `entity`는 일의 id대신 `일의 객체`를 가지고 있다?!
	![20220518001953](https://raw.githubusercontent.com/is2js/screenshots/main/20220518001953.png)


### Many의 entity 정의
- db간에는 id로 관계를 만든다 one(부모, id, pk) -> many(one_id,  fk)로 빌려주기
- many entity에서는 부모id가 아닌 부모 entity를 필드(칼럼)으로 가지면서
	- `@ManyToOne` 
	- `@JoinColumn(name = "one_id")`의 애너테이션으로는 entity가 db에 저장될때의 칼럼이름을 지정해준다.
- **my) one에서는 many정보가 없고, many에서만 one의 id(PK)를 fk(one_id)로 내려받아 관계를 형성한다.**

```java
public class Comment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne 
    @JoinColumn(name = "article_id")
    private Article article;
```

- 여기까지 댓글(many) entity를 완성하고, 
	1. 스프링부트 웹을 실행후, DDL log에 댓글 테이블이 만들어지는지 확인한다.
	2. 웹 h2 콘솔로 접속해 또 확인한다.
		![20220518082323](https://raw.githubusercontent.com/is2js/screenshots/main/20220518082323.png)
	```
	2022-05-18 08:21:11.380 DEBUG 24188 --- [           main] org.hibernate.SQL                        : 
    
    create table comment (
       id bigint generated by default as identity,
        body varchar(255),
        nickname varchar(255),
        article_id bigint,
        primary key (id)
    )

	2022-05-18 08:21:11.381 DEBUG 24188 --- [           main] org.hibernate.	SQL                        : 
    
    alter table comment 
       add constraint FK5yx0uphgjc6ik6hb82kkw501y 
       foreign key (article_id) 
       references article
	```

### jpa repository

- article은 db에 대해 CRUD만 하면 되었다
- comment의 reposoitory부터는 더 추상적인 인터페이스인 `JpaRepository`를 활용한다
	![20220518002612](https://raw.githubusercontent.com/is2js/screenshots/main/20220518002612.png)
	- CRUD + 일정페이지조회(Paging) + 정렬(Sorting) 기능까지 제공한다.
		![20220518002703](https://raw.githubusercontent.com/is2js/screenshots/main/20220518002703.png)


1. jparespository를 상속한 인터페이스 repository에 대해
	- 원하는 메서드를 `@Query` or `orm.xml`로 작성해줄 수 있다.
		![20220518095712](https://raw.githubusercontent.com/is2js/screenshots/main/20220518095712.png)

### 큰틀
1. 다(자식) entity 완성후 -> DDL log + h2웹콘솔에서 table 생성 확인
	- 하위도메인 entity에서는 상위 도메인 entity에 대해
		- 다대일 `@ManyToOne`
		- JoinColumn으로 fk 설정 `@JoinColumn(name = "article_id")`
	- **inteface repository에서는 추상메서드로 사용할 메서드를 정의하되 `@Query(value = "sql query", nativeQuery = true)` or resources > META-INF > `orm.xml`로 메서드를 구현했다.**


2. 부모 더미데이터 밑에 FK(entity)를 받는 자식 더미데이터 추가
	- 자식 더미데이터는 
		1. 1번째 필드(PK): `자신id는 순차적 증가` 
		2. 2번째 필드(FK):`1개의 부모를 고정시킨 FK(부모_id) 고정 묶음`으로 데이터 추가
		- 4번 (부모)게시글에 대한 && (자식)댓글들 1,2,3번 추가
			![![20220518090429](httpsraw.githubusercontent.comis2jsscreenshotsmain20220518090429.png)](https://raw.githubusercontent.com/is2js/screenshots/main/![20220518090429](httpsraw.githubusercontent.comis2jsscreenshotsmain20220518090429.png).png)
		- 5번 게시글에 대한 && 댓글들 4,5,6번 추가
		- 6번 게시를 && 7,8,9 댓글 추가
			![20220518090830](https://raw.githubusercontent.com/is2js/screenshots/main/20220518090830.png)

3. 재 실행해서, 콘솔로 db에 더미데이터 들어가있는지 확인
	- 각 게시글4,5,6번에 대해, 댓글들이 추가되었는지 확인한다.
		![20220518091029](https://raw.githubusercontent.com/is2js/screenshots/main/20220518091029.png)
4. 2개의 콘솔(부모 게시글 조회 + 자식 댓글들 조회)를 동시에 켜놓고 확인한다.
	- 부모 id(4번)에 대해 -> `fk(부모_id)를 필드로 가지면서 부모를 가리켜` 연결된 `다`의 데이터를 확인한다.
	- db에서는 데이터의 연결관계를 `id`를 통해서 연결되는 것을 확인한다.
	- **my) 자식들은 FK를 통해 -> 부모 PK를 가리키면서 연결이 형성된다.**
	![20220518091143](https://raw.githubusercontent.com/is2js/screenshots/main/20220518091143.png)
	![20220518091242](https://raw.githubusercontent.com/is2js/screenshots/main/20220518091242.png)

5. 3개의 콘솔을 켜서 sql 연습을 통해 확인한다.
	- **my) 일에서는 join해야하지만 다의 데이터를 가져오고**
	- **my) 다에서는 `join없이 FK를 이용`하여, `1개 부모에 대한 묶음 데이터`를 가져올 수 있다.**
		- 일의 데이터인 article의 정보가 필요한게 아니면, `일에 대한 묶음`은 join없이 가져온다.
	![20220518091547](https://raw.githubusercontent.com/is2js/screenshots/main/20220518091547.png)

	```sql
	-- 4번 게시글의 모든 댓글 가져오기
	SELECT
		*
	FROM
		comment
	WHERE
		article_id = 4;
		
	-- 닉네임이 park인 댓글들 가져오기
	SELECT
		*
	FROM
		comment
	WHERE
		nickname = 'Park';
	```
6. JpaRespository 상속한 comment respository 만들고
	1. 원하는 메서드 2개를 정의하되, @Query or orm.xml로 정의해준다.
	2. 서버를 재시작하고, `작성한 repository를 @DataJpaTest 테스트를 통해 확인`한다.

7. 작성한 repository test
	1. 테스트 파일을 만들고
	2. service test는 @SpringBootTest로서 스프링부터와 연동된 테스트였다면, **repository는 `@DataJpaTest`로서 `더 좁은 범위의 Jpa연동 테스트`를 수행한다.**
	3. `repository는 주입`받아서 사용한다.
	4. 메서드마다, 테스트메서드를 만들되, case는 내부에서 /**/중괄호를 활용하여 나눈다.
	5. 4단계로 나누어 테스트를 작성해본다.
		1. 실제수행 -> 메서드 인자는 입력데이터에 갈 변수로 추출
		2. 입력 데이터 준비 from 실제수행 메서드 인자
		3. 예상하기 -> 실제수행후 응답값과 같은 값을 db에서 	보고 준비
			- db속 데이터들은 콘솔에서 확인 -> 값 복붙 등으로 조회해서 활용한다.
			![20220518101814](https://raw.githubusercontent.com/is2js/screenshots/main/20220518101814.png)
			- 당장 없는 부모article은 자식들 다 작성후 -> 가장 위에 공통인 부모 article entity 1개 작성
		4. 검증하기
	6. 부모entity를 가진 entity라면, 부모에 대한 조회(부모1개 에 대한 자식 모음)가 아니더라도, **`해당하는 대응 부모entity`를 의미없이 `1개~여러개 만들어줘야 자식entity를 생성가능`하다**
		![20220518112516](https://raw.githubusercontent.com/is2js/screenshots/main/20220518112516.png)
		- **db 조회 확인하여 fk에 대응하는 부모를 개별로 다 만들어줘야한다.**
			- 대응하는 부모entity를 만들려면, 내용도 다 알아야해서 db에서 조회해서 확인해야한다.
				```sql
				select * from article where id in (select article_id from comment where nickname = 'Park');
				```
				![20220518113104](https://raw.githubusercontent.com/is2js/screenshots/main/20220518113104.png)
				```java
				            // ----> nickname 동일한 것으로 조회했으니, 변수로 뽑은 nickname "Park"자리에 재활용해준다.
				final Comment a = new Comment(1L, new Article(4L, "당신의 인생 영화는?", "댓글ㄱ"), nickname, "굳 월 헌팅");
				final Comment b = new Comment(4L, new Article(5L, "당신의 인생 푸드는?", "댓글ㄱㄱ"), nickname, "치킨");
				final Comment c = new Comment(7L, new Article(6L, "당신의 취미는?", "댓글ㄱㄱㄱ"), nickname, "조깅");
				// 3) asList로 묶어서 응답형과 맞춰준다.
				final List<Comment> expected = Arrays.asList(a, b, c);
				```




### 댓글들

홍팍님이 고정함
Mingi Kim
4개월 전
Comment Test중 에러가 나서 찾아보니 파라미터값을 못찾나봐요. 저는 CommentRepository 에서 finByArticleId(@Param("articleId") Long articleId) 로 @Param 어노테이션으로 매핑해 해결했습니다.


robot
robot
2개월 전
findByNickname 메소드 테스트할 때 에러 떠도 마찬가지로 CommentRepository에서 findByNickname(@Param("nickname") String nickname) 으로 수정하니까 해결되네요.


안녕하세요! 강의 잘보고있습니다.. 네이티브 쿼리를 xml파일로 하실 때 예제코드가 잘 안보이고 구글링해서 버전맞는거나 찾기가 어렵습니다. 이후에 예제쿼리코드도 그렇고, 강의 내용의 코드를 공유하거나 같이 볼수있는 깃허브같은게 있었으면 좋겠다싶습니다. 안되도 어쩔수없지만요..


피드백 감사합니다
복붙용 코드를 공유할 수 있게 준비해볼게요


4개월 전(수정됨)
22강 관련 실습 코드를 
다음 링크에서 확인하실 수 있습니다.
https://cloudstudying.kr/lectures/484



홍팍님 Comment 엔티티 클래스에 필드로 Article이 통쨰로 들어가는 이유는 무엇인가요 ?

어차피 DB에서도 article_id로 만들어질거면 그냥 article_id로 넣어도 될 것 같은데 다른 이유가 있나요 ??


홍팍
- `Article을 통`으로 넣으면, `추후 댓글의 상위 Article을 단 한 줄로 가져올 수 있습니다.`
```java
// 해당 댓글의 상위 아티클 조회
Article article = comment.getArticle();
```
- 이러한 코드가 가능한 것은 `JPA가 자동으로 두 테이블을 조인`해주기 때문인데요.

- `article_id를 바로 담는것은 JDBC와 Mybatis 활용 시 표준`으로 사용됩니다.

좋은 질문 감사합니다!

PS.
다음 테스트 코드에서 수행되는
쿼리를 분석해보세요.
```java
@Test
void JPA를_활용한_댓글과_아티클_조회() {
    // 준비
    Comment comment = commentRepository.findById(1L).orElse(null);
    System.out.println(comment);

    // 수행
    Article article = comment.getArticle();
    System.out.println(article);

    // 예상
    Article expected = articleRepository.findById(4L).orElse(null);

    // 검증
    assertEquals(expected.toString(), article.toString());
}
```


Kyah
3개월 전
 @홍팍      
늦은 시간에 답변 감사합니다.

JPA는 자동으로 조인을 해주기 때문에 Article을 넣어주는게 좋고

 JDBC, Mybatis 등에선 조인을 자동으로 해주지 않으니 굳이 Article을 통째로 넣을 필요가 없다라고 이해하면 될까요 ??

그리고 올려주신 테스트 코드 쿼리를 봤는데 이렇게 left outer join으로 article_id를 사용해서 조인이 되는 모습이네요

select
        comment0_.id as id1_1_0_,
        comment0_.article_id as article_4_1_0_,
        comment0_.body as body2_1_0_,
        comment0_.nickname as nickname3_1_0_,
        article1_.id as id1_0_1_,
        article1_.content as content2_0_1_,
        article1_.title as title3_0_1_ 
    from
        comment comment0_ 
    left outer join
        article article1_ 
            on comment0_.article_id=article1_.id 
    where
        comment0_.id=?



근데 articleRepository.findByid(4L) 부분의 쿼리는 보이지 않네요 

아무리 봐도 저 부분에 대한 Select문은 보이지가 않는데 안나오는 이유가 뭔가요..?



홍팍
홍팍
3개월 전(수정됨)
===
JPA는 
자동으로 조인을 해주기 때문에 
Article을 넣는게 좋다?
===
 Yes

===
JDBC, Mybatis 등에선
굳이 Article을 넣을 필요가 없다
===
Yes

===
articleRepository.findByid(4L) 쿼리는 ㅇㄷ??
===
- **JPA는 "영속성 컨텍스트"라는 일종의 "DB 캐시(임시 창고)"를 가집니다.**
	- **JPA는 조회 쿼리를 날리기 전 이곳에서 조회 대상을 먼저 찾는데요**
	- **데이터가 찾아진는 경우, 쿼리를 수행하지 않고 해당 데이터를 그대로 반환합니다**.
	- **이러한 이유로 articleRepository.findByid(4L)의 쿼리는 전송(flush)되지 않습니다 (comment 조회시 4번 article이 캐싱됨)**

더 자세한 내용은
"JPA 영속성 컨텍스트"
정도로 구글링해보세요!


요즘에는 네이티브쿼리를 어노테이션에서 하는게추세인가요 아니면 xml로 하는 추세인가요??
어떤게 더 좋나요??


- **보통 `쿼리가 복잡한 또는 최적화`가 필요한 경우에 `xml`을,**
- **`쿼리가 단순`한 경우에 `어노테이`션이 좋습니다.**